---
export interface Props {
  baseValue?: number;
  incrementRate?: number;
  updateInterval?: number;
  label?: string;
}

const {
  baseValue = 230000,
  incrementRate = 1,
  updateInterval = 10000, // 10 seconds
  label = 'TESTS TAKEN'
} = Astro.props;

// Generate unique ID for this component instance
const componentId = `flip-counter-${Math.random().toString(36).substr(2, 9)}`;
---

<div class="flip-counter" data-base-value={baseValue} data-increment-rate={incrementRate} data-update-interval={updateInterval} data-component-id={componentId}>
  <div class="counter-label">{label}</div>
  <div class="counter-display" id={`${componentId}-display`}>
    <!-- Digits will be generated by JavaScript -->
  </div>
</div>

<script>
  class FlipCounter {
    constructor(element) {
      this.element = element;
      this.componentId = element.dataset.componentId;
      this.baseValue = parseInt(element.dataset.baseValue) || 230000;
      this.incrementRate = parseInt(element.dataset.incrementRate) || 1;
      this.updateInterval = parseInt(element.dataset.updateInterval) || 10000;
      this.currentValue = this.calculateTimeBasedValue();
      this.display = element.querySelector(`#${this.componentId}-display`);
      this.counterInterval = null;
      
      this.init();
    }
    
    calculateTimeBasedValue() {
      // Calculate value based on time since January 1st of current year
      const now = new Date();
      const startOfYear = new Date(now.getFullYear(), 0, 1, 0, 0, 0, 0);
      const diffMs = now.getTime() - startOfYear.getTime();
      const minutes = Math.floor(diffMs / 60000);
      
      // Add 1 test every 15 minutes (4 per hour)
      const timeBasedIncrement = Math.floor(minutes / 15);
      return this.baseValue + timeBasedIncrement;
    }
    
    init() {
      this.updateDisplay();
      this.startCounter();
    }
    
    get displayDigits() {
      return String(this.currentValue).padStart(6, '0').split('');
    }
    
    updateDisplay() {
      // Clear existing digits
      this.display.innerHTML = '';
      
      // Create digit containers
      this.displayDigits.forEach((digit, index) => {
        const container = document.createElement('div');
        container.className = 'digit-container';
        
        const pivot = document.createElement('div');
        pivot.className = 'pivot';
        
        const digitElement = document.createElement('div');
        digitElement.className = 'digit';
        digitElement.textContent = digit;
        digitElement.setAttribute('data-digit', digit);
        
        container.appendChild(pivot);
        container.appendChild(digitElement);
        this.display.appendChild(container);
      });
    }
    
    animateDigitChange(container, newDigit) {
      const currentDigit = container.querySelector('.digit');
      
      // Create new digit element
      const newDigitElement = document.createElement('div');
      newDigitElement.className = 'digit flip-enter';
      newDigitElement.textContent = newDigit;
      newDigitElement.setAttribute('data-digit', newDigit);
      
      // Add to container
      container.appendChild(newDigitElement);
      
      // Animate out old digit
      currentDigit.classList.add('flip-leave-to');
      
      // Animate in new digit
      requestAnimationFrame(() => {
        newDigitElement.classList.remove('flip-enter');
        
        // Remove old digit after animation
        setTimeout(() => {
          if (currentDigit.parentNode) {
            currentDigit.parentNode.removeChild(currentDigit);
          }
        }, 400);
      });
    }
    
    updateValue() {
      // Recalculate time-based value to stay in sync
      const newTimeBasedValue = this.calculateTimeBasedValue();
      
      // If enough time has passed for the counter to increment naturally
      if (newTimeBasedValue > this.currentValue) {
        const oldDigits = this.displayDigits;
        this.currentValue = newTimeBasedValue;
        const newDigits = this.displayDigits;
        
        // Find which digits changed and animate them
        const containers = this.display.querySelectorAll('.digit-container');
        
        newDigits.forEach((digit, index) => {
          if (oldDigits[index] !== digit && containers[index]) {
            this.animateDigitChange(containers[index], digit);
          }
        });
      }
    }
    
    startCounter() {
      // Check for updates every 10 seconds (but only increment every 15 minutes based on real time)
      this.counterInterval = setInterval(() => {
        this.updateValue();
      }, this.updateInterval);
    }
    
    destroy() {
      if (this.counterInterval) {
        clearInterval(this.counterInterval);
      }
    }
  }
  
  // Initialize flip counters when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const flipCounters = document.querySelectorAll('.flip-counter');
    flipCounters.forEach(element => {
      new FlipCounter(element);
    });
  });
  
  // Cleanup on page unload  
  window.addEventListener('beforeunload', () => {
    // FlipCounter instances will be garbage collected automatically
  });
</script>